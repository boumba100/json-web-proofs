{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-10-07T00:40:36.486953+00:00",
  "repo": "json-web-proofs/json-web-proofs",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "JSDT",
      "description": "JSON Selective Disclosure Token",
      "color": "8BF97D"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU5NDgxMTE0ODg=",
      "title": "Alternative format for credential claims",
      "url": "https://github.com/json-web-proofs/json-web-proofs/issues/2",
      "state": "OPEN",
      "author": "dwaite",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "JSDT"
      ],
      "body": "I would like to propose an alternative format for credential claims from metadata:\r\n\r\n## Payload slot metadata\r\n``` json\r\n{ \"claims\": [\"family_name\", \"given_name\"] }\r\n```\r\n\r\n## Corresponding payload slot\r\n``` json\r\n[\"Waite\", \"David\"]\r\n```\r\n\r\nThe claims payload property is always an array of one or more keys, while the slot would be an array of one or more values.\r\n\r\nA credential-level specification can use this definition for combining claims into a JSON document, including how to combine multiple payload slots into a resulting JSON document for exposure to the application level on the verifier.\r\n\r\nOne motivation here is to have a simplified path-like syntax for the claims names for describing how to compose more complex documents, e.g. a payload slot metadata of:\r\n\r\n``` json\r\n{\"claims\": [\"address.postal_code\", \"address.country\"] }\r\n```",
      "createdAt": "2021-07-19T23:33:58Z",
      "updatedAt": "2021-09-21T18:17:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "While this has a very nice simplicity to it, I do believe it will be necessary to support additional header values per-payload such as content type.  One alternative strategy might be for JWP to require the JWK simply uniquely _name/identify_ each payload, and that applications must be able to determine the content type from the name/id by context or some external mechanism. This is similar to how the JWT defines certain claim names and the exact type of value for each (`NumericDate`, `StringOrURI`, etc) and it's opaque to the JWS.\r\n\r\nThis would look something like:\r\n```json\r\n{ \"payloads\": [\"family_name\", \"given_name\", \"E18FF842\", \"http://www.w3.org/2002/12/cal/ical#\"] }\r\n```\r\n\r\nThe path-like syntax would only be relevant to applications that want to re-combine multiple payloads, and given the privacy focus of JWP I'm not sure that is a safe approach to encourage.  Applications will need to understand for any given payload if the result is from a proof (predicate, boolean, etc) and should not rely on always expecting the raw claim values.",
          "createdAt": "2021-08-18T00:28:02Z",
          "updatedAt": "2021-08-18T00:45:58Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since we seem to have a  primary pattern of data applied to a template [e.g. [MadLibs](https://www.madlibs.com)] there could be a lot of variance and bike shedding to how we describe JWT-style claims. I suggest we try to have a solid initial proposal before going to a wider group, and be willing to encourage multiple sheds if things are too divergent.",
          "createdAt": "2021-09-06T21:57:37Z",
          "updatedAt": "2021-09-06T21:57:37Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU5NTA5NTAyMzE=",
      "title": "JWP does not separate the signing layer from the claims layer, like JWS and JWT do",
      "url": "https://github.com/json-web-proofs/json-web-proofs/issues/4",
      "state": "OPEN",
      "author": "selfissued",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "JWS signs a binary payload that it knows nothing about.  JWT specifies a binary payload that is an encoding of JSON claims.  The JWT spec currently specifies signing an array of payloads but *also* specifies sets of claim names for these payloads.\r\n\r\nI'd like us to think about whether we should factor the signing part and the claims part into layered specs, analogous to JWS and JWT.  I realize that we'd still have to declare the list of payloads tied to the key in a way that didn't leak information.  And that if we layer the signing and the claims, we'd likely also have to declare the claims in a way that matched the payloads and that didn't also leak information.\r\n\r\nRestructuring things this way may be more work, but we may end up thanking ourselves because the resulting specs will be more general.",
      "createdAt": "2021-07-22T18:45:27Z",
      "updatedAt": "2021-09-21T17:19:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "NONE",
          "body": "I think separating the signing and claims layer would definitely open up more flexibility for JWP to be used in existing proof systems that use aggregated signatures. One way to tackle this would be adding opportunity to describe the claims layer, similar to how JWK can describe the claims, but part of the JWP in a privacy preserving way.\r\n\r\nBBS payloads are a set of hashed messages, and those messages can either be a set of direct claims, or canonical representation of some other data structure. Some examples on potential BBS payloads:\r\n\r\nClaims payload\r\n```js\r\n'{ \"email\":\"janedoe@example.com\"}'\r\n```\r\n\r\nN-Quad payload\r\n```js\r\n'_:c14n0 <http://schema.org/email> \"janedoe@example.com\" .'\r\n```\r\n\r\nJSON Pointer payload\r\n```js\r\n'{ \"/account/email\": \"janedoe@example.com\" }'\r\n```\r\n\r\nURI payload\r\n```js\r\n'https://example.com/person.json#/email'\r\n```\r\n\r\nSome of these payloads (Claims and URI) directly represent the signed data while N-Quads and JSON Pointer are canonical representations of the actual data. It becomes clear that JWP shouldn't include the canonical form of the signed data, as clients would be required to reconstruct it in order to use it, but this may not always be possible.\r\n\r\nI think the JWP could allow some sort of additional indicator that described what the data is that would point to the canonicalization algorithm and include the original payload in the `payloads` field.\r\n\r\nFor example:\r\n\r\n```js\r\n{\r\n  \"protected\": {\r\n    \"typ\": \"JWP\",\r\n    \"alg\": \"BBS-BLS12381\",\r\n    \"crit\": [ \"c14n\" ],\r\n    \"c14n\": \"URDNA2015\" // field name can be different, example only\r\n  },\r\n  \"payloads\": {\r\n    \"@context\": \"https://schema.org\",\r\n    \"email\": \"janedoe@example.com\"\r\n    // JSON object can be any depth\r\n  }\r\n}\r\n```\r\n\r\nThis approach will uniquely describe the final set of claims that will be signed with the specified algorithm.\r\nWhen claims are used, the `c14n` field can be omitted and systems assume the format as currently described in JWP. This approach will also allow selective disclosure with BBS.\r\n",
          "createdAt": "2021-08-24T12:41:46Z",
          "updatedAt": "2021-08-24T12:45:54Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @tmarkovski, I think I follow your line of thinking.\r\n\r\nOne of the design principles of JWP is to strictly separate the static metadata that describes a payload from the actual signed payload values.  The purpose of this is to maximize unlinkability by ensuring that a JWP cannot be constructed improperly such that the location of a payload reveals identifying information.\r\n\r\nThat is the reason for having the payloads field in the JWK for any JWP, it contains the static information relating to that specific payload so that the issuer can only put those values in the same payload slots every time that key is used.\r\n\r\nHow that information is added to the JWK is definitely an area that needs to be developed, what is in the proposal right now using the \"payloads\" field is not scalable and really just an initial starting place.\r\n\r\nFor example, in each of your above snippets the JWK could contain something like this (I'm proposing here \"layout\" to identify the type of payload layout definition used):\r\n```json\r\n{\r\n    \"layout\":\"claims\",\r\n    \"claims\":[\"email\",,,]\r\n}\r\n```\r\n```json\r\n{\r\n    \"layout\":\"n-quads\",\r\n    \"n-quads\":\"_:c14n0 <http://schema.org/email> _:jwp0 .\\r\\n...\"\r\n}\r\n```\r\n```json\r\n{\r\n    \"layout\":\"pointers\",\r\n    \"pointers\":[\"/account/email\",,,]\r\n}\r\n```\r\n```json\r\n{\r\n    \"layout\":\"uris\",\r\n    \"uris\":[\"http://example.com/app_specific_reference\",,,]\r\n}\r\n```\r\n\r\nThe intent here is just to ensure that the application has a single uniform definition of what the payload value in each slot represents.\r\n\r\nAs to reconstruction, I believe that should be up to the application to determine the appropriate usage and the JWP definition should support either modality.  Payload values may be reconstructed into a document (if they're available after selective disclosure) or the application may process each payload in its own individual context (such as when using predicate proofs).",
          "createdAt": "2021-09-01T21:28:41Z",
          "updatedAt": "2021-09-01T21:30:04Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "I am not sure I am reading this correctly, but I think the ideal solution would look something like this:\r\n\r\n```\r\nheader: { alg, kid }\r\npayload: JSON Object (string encoded)\r\nproof: { signature (s) + other proof data related to alg }\r\n```\r\n\r\nthen under `alg`:\r\n\r\nA description of the required members of proof and requirements for payload.\r\n\r\nFor example: `BLS_BBS+JSON_POINTER` or `MERKLE+JWS+JSON_POINTER` \r\n \r\nIn other words.... use `alg` to declare normalization (or any form of \"payload transform\"), and require payload to be an opaque `object`.\r\n\r\nfrom this perspective, a JWT is a JWP, with an implied normalization process of: `base64url(header).base64url(payload)`.\r\n\r\nJWP can then inherit JWS alg's for example: `ES256K`, with the only encoding change being `signature` -> `proof`",
          "createdAt": "2021-09-07T19:26:35Z",
          "updatedAt": "2021-09-07T19:33:30Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there's two things in your comment @OR13, first is your examples are all single-payload, whereas JWP is for natively supporting multiple payloads.\r\n\r\nThere's also an important perspective-change with JWP relating to what I think you're suggesting.  The payloads are intended to be used for single values, not composite structures.  I'm working on a draft update to JWP to help clarify this and we can review it at the next meeting.\r\n\r\nThis is where @dwaite's \"[Mad Libs](https://github.com/json-web-proofs/json-web-proofs/issues/2#issuecomment-913865953)\" analogy applies: a credential document only has the privacy sensitive values stored in the payload slots (such as the expiration timestamp is in slot 2, age value is in slot 5, email is in slot 7, etc).  The JWK that was used to issue/derive/verify for that JWP must contain the \"layout\" for the application to identify what values are in what slots.\r\n\r\nDiscussion and working through any confusion on this is excellent, definitely helping highlight areas to improve, thank you!\r\n",
          "createdAt": "2021-09-08T00:31:37Z",
          "updatedAt": "2021-09-08T00:31:37Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "> JWP is for natively supporting multiple payloads.\r\n\r\nThis will cause the verifier to have to understand something of the payloads... at the very least, that each of them is independently valuable.\r\n\r\nAre the payloads really independent?\r\n\r\nwill a verifier need to parse each payload independently?\r\n\r\nconsider a scenario where one payload is encoded with `JCS` but the other is encoded with `JSON.stringify` is this allowed?\r\n\r\nForcing payloads to be assembled into data models at the application layer, will prevent JWP from being capable of representing object data models natively, and will require a per object type translation for each standard object data model....\r\n\r\nFor example:\r\n\r\n- https://w3c.github.io/vc-data-model/#credential-subject\r\n- https://w3c.github.io/webauthn/#clientdatajson-serialization\r\n- https://json-schema.org/understanding-json-schema/about.html\r\n- https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc#fetch-the-openid-connect-metadata-document\r\n\r\nin each case, we start with an object, than transform it to a set of JWP payloads, then transform it back (so it conforms with the normative object definition)... \r\n\r\nIf JWP does not define 1 way of doing this, I expect it will happen many different ways... which will harm interop, but perhaps another spec will define the way to use JWP to objects....\r\n\r\n*moving normalization and aggregation outside of JWP might be strategic....*\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-09-13T18:29:21Z",
          "updatedAt": "2021-09-13T18:30:39Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "> moving normalization and aggregation outside of JWP might be strategic....\r\n\r\nAgreed, it clicked for me last week that there can and should be a much clearer separation of concerns.\r\n\r\nThe current JWP draft needs some improvement on this front which I'm working on, reducing it to a simpler core container primitive that can be easily used with external mechanisms.\r\n\r\nI do suspect there may be an eventual need for multiple of those external mechanisms, and they will definitely still require strong privacy considerations in order to preserve the underlying unlinkability.",
          "createdAt": "2021-09-14T22:28:24Z",
          "updatedAt": "2021-09-14T22:28:24Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "If we do allow for `normalization` and `aggregation` outside of JWP, we can treat the message payloads as 100% opaque JSON, which would be nice... since we don't have to care about how or if they are assembled into objects that conform to existing standards.... but I suspect many folks will still want an answer to the latter, around the same time.\r\n\r\n",
          "createdAt": "2021-09-20T16:01:21Z",
          "updatedAt": "2021-09-20T16:01:21Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm working on a PR to reduce the scope of the JWP draft to just the signing/proving aspects, moving the payload values and any mappings out of scope: https://github.com/json-web-proofs/json-web-proofs/pull/10\r\n\r\nWe unfortunately cannot specify that the payload values are all JSON, it's essential that a proof algorithm has the ability to receive custom or raw values in order to support blinded values and/or numerical operations for range and membership proofs.\r\n\r\nSupporting these does result in a more detailed programmatic API where each payload may have individual options passed into the algorithm, but I believe it's still the simplest abstraction that still supports the larger scope of proof capabilities.\r\n\r\nFor example, a builder pattern of the initial issuance:\r\nPseudocode:\r\n```\r\nsigner = algo.signer(issuer_key, options) // options may include binding details\r\nsigner.setProtected(base64url(protected header))\r\nsigner.addPayload(payload1, options) // options may signal a blinded or numerical value\r\nsigner.addPayload(payload2)\r\nsigner.addPayload(payload3)\r\nsig = signer.sign()\r\n```\r\n",
          "createdAt": "2021-09-20T16:23:07Z",
          "updatedAt": "2021-09-20T16:23:07Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "`signer.addPayload(payload1, options) ` \r\n\r\ndoesn't this just get converted to \r\n\r\n`encoded proof : [ ...,  payload1WithAppliedOptions]` \r\n\r\nis JWP a data format or a protocol for constructing data formats?\r\n\r\nalso, might suggest changing the name before its too late.... `Json Web Proof`... implies it's a JSON based cryptographic data format...  You can encode both numbers and binary in JSON, and you can use JWS to sign binary with detached JWS `b64: false` and `crit: ['b64']`... \r\n\r\nSee https://datatracker.ietf.org/doc/html/rfc7797, you would probably want something similar if it's `critical` a verifier understands some message payloads be processed according to `options` in a specific way.\r\n\r\n\r\nIf the output is JSON, thats good enough reason to keep the name as is... and also to define the inputs in ways that are familiar to JSON developers.",
          "createdAt": "2021-09-20T17:07:40Z",
          "updatedAt": "2021-09-20T17:13:10Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "> `signer.addPayload(payload1, options) `\r\n> \r\n> doesn't this just get converted to\r\n> \r\n> `encoded proof : [ ..., payload1WithAppliedOptions]`\r\n\r\nCorrect, it just has to be the algorithm that applies the options.\r\n\r\n> is JWP a data format or a protocol for constructing data formats?\r\n\r\nIt's just a data format.  Though it does create expectations for supporting protocols to convey various options.\r\n\r\n> also, might suggest changing the name before its too late.... `Json Web Proof`... implies it's a JSON based cryptographic data format... You can encode both numbers and binary in JSON, and you can use JWS to sign binary with detached JWS `b64: false` and `crit: ['b64']`...\r\n> \r\n> See https://datatracker.ietf.org/doc/html/rfc7797, you would probably want something similar if it's `critical` a verifier understands some message payloads be processed according to `options` in a specific way.\r\n\r\nIt's currently as much JSON as JWS is, and I agree we could use JSON encoding for the numbers/binary.  It'll be one of the topics I expect ongoing discussion on, as using JSON would require the algorithm implementations also parse/decode the JSON so that they can work with the raw values cryptographically.\r\n\r\nMy current preference is that they are always just opaque base64url encoded values as far as JWP is concerned, and any extra signals about their contents or algorithmic handling is out of scope.  That said, my expectation is we would also work on a companion spec that focuses on those details, very similar to the JWS/JWT relationship as suggested by @selfissued in this issue. \r\n",
          "createdAt": "2021-09-20T18:21:02Z",
          "updatedAt": "2021-09-20T18:21:02Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "I tend to agree that small, well defined building blocks, layered correctly is a much better approach than a monolithic spec that defines everything.\r\n\r\nI don't see a way around parsing... given the potential complexity of header values.\r\n\r\nDoes this refinement of your original example align with your thinking?\r\n\r\n```\r\nsigner = algo.signer(issuer_key, options) // options may include binding details\r\nsigner.setProtected(base64url(JSON.stringify( header ))) // may refer to signing key and blinding details\r\nsigner.addPayload(base64url(JSON.stringify({payload: payload1, options})) // options may signal a blinded or numerical value\r\nsigner.addPayload((base64url(JSON.stringify({payload: payload2))\r\nsigner.addPayload((base64url(JSON.stringify({payload: payload3))\r\nsig = signer.sign()\r\n```",
          "createdAt": "2021-09-21T14:07:25Z",
          "updatedAt": "2021-09-21T14:07:25Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Your refinement is I believe in the right ballpark, it still supports the primary goal in the new PR of minimizing the scope to only what the algorithm requires in order to sign/prove.\r\n\r\nDefinitely something to discuss at today's work item call.",
          "createdAt": "2021-09-21T17:19:36Z",
          "updatedAt": "2021-09-21T17:19:36Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU5NTA5NTQ4MjM=",
      "title": "Content type syntax for claims in payloads not fully general",
      "url": "https://github.com/json-web-proofs/json-web-proofs/issues/5",
      "state": "OPEN",
      "author": "selfissued",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "JSDT"
      ],
      "body": "The example content type syntax for claims in payloads does not allow different content type values to apply to different claims in the same payload.  The current example syntax in the spec is:\r\n`   \"payloads\":[\r\n      {\"claims\":[\"family_name\", \"given_name\"]},\r\n      {\"claims\":[\"email\"]},\r\n      {\"claims\":[\"birthdate\"]},\r\n      {\"claims\":[\"age\"], \"cty\":\"hashchain-commitment\"},\r\n      {\"claims\":[\"profile_pic\"], \"cty\":\"image/png\"}\r\n   ]\r\n`\r\nI don't see a way to, for instance have have a `profile_pic_png` claim with content type `image/png` and a `profile_pic_jpg` claim with content type `image/jpeg` in the same payload.",
      "createdAt": "2021-07-22T18:52:06Z",
      "updatedAt": "2021-09-21T18:17:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would you be looking for something like:\r\n\r\n``` json\r\n[\r\n  { \"claims\": [\"profile_pic\"], \"cty\": \"image/png\" },\r\n  { \"claims\": [\"profile_pic\"], \"cty\": \"image/jpeg\" }\r\n]\r\n```\r\n\r\nor\r\n\r\n``` json\r\n[\r\n  { \"claims\": [\"profile_pic_png\"], \"cty\": \"image/png\" },\r\n  { \"claims\": [\"profile_pic_jpg\"], \"cty\": \"image/jpeg\" }\r\n]\r\n```\r\n",
          "createdAt": "2021-07-22T19:19:39Z",
          "updatedAt": "2021-07-22T19:19:39Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU5NzMxNTQ3OTY=",
      "title": "COSE definition for proof support",
      "url": "https://github.com/json-web-proofs/json-web-proofs/issues/7",
      "state": "OPEN",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Similar to adapting JWP for JOSE by creating a new top-level type, COSE will also need the same treatment.\r\n\r\nCOSE currently has three major types for Sign, Encrypt, and Mac, each with their own variant for the common use cases of single signer/recipient of Sign1, Encrypt0, and Mac0.\r\n\r\nPlan is to introduce a fourth major type of Proof and Proof1, who's definition is very similar to Sign/Sign1 but instead of a bstr payload it would be:\r\n```cddl\r\nCOSE_Proof1 = [\r\n       Headers,\r\n       payloads : [+ bstr / nil],\r\n       proof : bstr\r\n]\r\n```\r\n",
      "createdAt": "2021-08-18T00:11:59Z",
      "updatedAt": "2021-09-21T18:24:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposing to add to draft, include note that it may become own spect.",
          "createdAt": "2021-09-21T18:24:08Z",
          "updatedAt": "2021-09-21T18:24:08Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU5ODU3MzEwODA=",
      "title": "Proof Value",
      "url": "https://github.com/json-web-proofs/json-web-proofs/issues/8",
      "state": "OPEN",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As with JWS's signature value, the format of the proof value is opaque to the application.  The proof algorithm defines the format and any encoding is unique to that algorithm.\r\n\r\nOf note, for proof algorithms that support proofs of knowledge or predicate proofs of the values in individual payload slots, each of those proofs uniquely generated during derivation must also be encoded/stored in the overall proof value.\r\n\r\nThese proof algorithms must also provide a programmable interface to applications such that they can request the generation and validation of a proof for each payload.  These interfaces will be unique to the algorithm and its proofing capabilities and may vary significantly from one algorithm to another depending on the underlying cryptographic primitives.\r\n\r\nSince some proof algorithms will require the predicate statement during derivation, applications must take care to limit or require consent on multiple derivations such that a hostile party cannot simply continue to refine the predicate request in order to gain more knowledge of the hidden value.\r\n\r\nThe format of any predicate requests are inherently algorithm and application/protocol context specific, these formats are out of scope of the JWP specification.",
      "createdAt": "2021-09-01T21:47:33Z",
      "updatedAt": "2021-10-05T20:03:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "See discussion thread here: https://github.com/json-web-proofs/json-web-proofs/pull/10#discussion_r716084233 and https://github.com/json-web-proofs/json-web-proofs/pull/10#discussion_r716086161",
          "createdAt": "2021-10-05T19:38:29Z",
          "updatedAt": "2021-10-05T20:03:30Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU5OTAyNjE4MTc=",
      "title": "Proof Algorithm Interface",
      "url": "https://github.com/json-web-proofs/json-web-proofs/issues/9",
      "state": "OPEN",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Using this issue to track discussions around the common interface to the proof algorithm for the signing, deriving, and verifying steps.",
      "createdAt": "2021-09-07T19:00:55Z",
      "updatedAt": "2021-09-07T19:00:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDOFsQObc47x-Eb",
      "title": "Expand terminology section",
      "url": "https://github.com/json-web-proofs/json-web-proofs/issues/11",
      "state": "OPEN",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Include the few ZKP terms being introduced.",
      "createdAt": "2021-09-21T17:49:27Z",
      "updatedAt": "2021-09-21T17:49:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOFsQObc48B3YC",
      "title": "Require explicit disclosure?",
      "url": "https://github.com/json-web-proofs/json-web-proofs/issues/12",
      "state": "OPEN",
      "author": "OR13",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some proof types have 2 representations, a. \"root\" or \"full disclosure\" format... and a \"derived\" or \"selective disclosure format\"...\r\n\r\nBBS+ is an example.\r\n\r\nWhile it is possible to verify both formats, I wonder if there is some developer / user experience benefit to refusing to verify the \"root\" type... \r\n\r\nThis might help discourage sharing every attribute, since no verifier (that cared deeply about user privacy) would accept the root format... this would cause the holder to explicitly derive a subset (potentially not strict) of attributes every time they wanted to present a proof.\r\n\r\nPerhaps such privacy considerations are not appropriate for this layer of debate, but certainly clever registration of algorithms might help user privacy here....\r\n\r\n\r\nFor example:\r\n\r\n`BbsBlsSignature2020` -> registered but prohibited.\r\n`BbsBlsSignatureProof2020` -> registered and required.\r\n\r\n",
      "createdAt": "2021-09-25T15:54:42Z",
      "updatedAt": "2021-10-05T00:39:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an excellent privacy consideration, though I would expect it to be in the presentation exchange layer so that it applies unilaterally to both the format and to any selectively disclosable linkable attributes.\r\n\r\nAs per relating to JWPs, the draft needs to have language added such that an algorithm's verification method MUST NOT verify a JWP that has only been signed and not derived/proofed.  That will at least prevent just disclosing the raw issued JWP without having at least run it through the proof generation.",
          "createdAt": "2021-10-05T00:39:03Z",
          "updatedAt": "2021-10-05T00:39:03Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOFsQObc48mHvc",
      "title": "Naming Things",
      "url": "https://github.com/json-web-proofs/json-web-proofs/issues/13",
      "state": "OPEN",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Using this issue to resolve outstanding naming discussions:\r\n- [ ] derive proof vs. generate proof\r\n- [ ] signing vs. generate proof\r\n- [ ] JSDT (JSON Selective Disclosure Token) vs ??? for companion spec to JWP",
      "createdAt": "2021-10-05T17:59:46Z",
      "updatedAt": "2021-10-05T20:01:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "My dilemma w/ \"JSDT\" is that it doesn't encompass the unlinkability aspect, which IMO is equally important as a principal foundation for a companion spec.  Selective disclosure is also just one aspect of the data minimization approach.\r\n\r\nPerhaps \"Minimization\" is the root of both aspects? Maybe JMP/JMT or JMDP/JMDT for Minimized or Minimal Disclosure? My inner nerd likes JMP/JMT because it's just the W flipped :) ",
          "createdAt": "2021-10-05T19:31:32Z",
          "updatedAt": "2021-10-05T19:31:32Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "See discussion thread here: https://github.com/json-web-proofs/json-web-proofs/pull/10#discussion_r716082098 and https://github.com/json-web-proofs/json-web-proofs/pull/10#discussion_r716083442",
          "createdAt": "2021-10-05T19:39:43Z",
          "updatedAt": "2021-10-05T20:01:28Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg4MjgxMzEx",
      "title": "Initial Importing",
      "url": "https://github.com/json-web-proofs/json-web-proofs/pull/1",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This brings in the rest of the [original HackMD markdown](https://hackmd.io/@quartzjer/JSON_Web_Proof).",
      "createdAt": "2021-07-13T00:32:40Z",
      "updatedAt": "2021-07-14T04:48:41Z",
      "baseRepository": "json-web-proofs/json-web-proofs",
      "baseRefName": "main",
      "baseRefOid": "0f75b328d6cfdefbae51e74efa454f01d2829922",
      "headRepository": "json-web-proofs/json-web-proofs",
      "headRefName": "initial_full_import",
      "headRefOid": "6837298d451ff78e3aff48f14574cedc58dd5b4b",
      "closedAt": "2021-07-14T04:48:41Z",
      "mergedAt": "2021-07-14T04:48:41Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "31a96070dfb473391d45bb51105165dca2bbdc6d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA1ODQ5MDc2",
          "commit": {
            "abbreviatedOid": "6837298"
          },
          "author": "dwaite",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "looks great!",
          "createdAt": "2021-07-14T04:48:35Z",
          "updatedAt": "2021-07-14T04:48:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NDEwMTQy",
      "title": "Update draft-jmiller-json-web-proofs.md",
      "url": "https://github.com/json-web-proofs/json-web-proofs/pull/3",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Mike's initial suggestions",
      "createdAt": "2021-07-22T18:34:05Z",
      "updatedAt": "2021-07-22T19:03:24Z",
      "baseRepository": "json-web-proofs/json-web-proofs",
      "baseRefName": "main",
      "baseRefOid": "31a96070dfb473391d45bb51105165dca2bbdc6d",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-initial-suggestions",
      "headRefOid": "b92901747936fc39e007f0e1a678767fa7be1f2b",
      "closedAt": "2021-07-22T19:03:24Z",
      "mergedAt": "2021-07-22T19:03:24Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "facb77d408bf07cbdc7096980149bdebad3eddcb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzMTM3OTg5",
          "commit": {
            "abbreviatedOid": "b929017"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-22T19:00:43Z",
          "updatedAt": "2021-07-22T19:00:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NDMwMjIy",
      "title": "Renames to be a consistent singular",
      "url": "https://github.com/json-web-proofs/json-web-proofs/pull/6",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "No material content changes.",
      "createdAt": "2021-07-22T19:08:43Z",
      "updatedAt": "2021-07-24T07:37:28Z",
      "baseRepository": "json-web-proofs/json-web-proofs",
      "baseRefName": "main",
      "baseRefOid": "facb77d408bf07cbdc7096980149bdebad3eddcb",
      "headRepository": "json-web-proofs/json-web-proofs",
      "headRefName": "rename_singular",
      "headRefOid": "f3d8703187a7854c59791796cbb3c5faf160b0ec",
      "closedAt": "2021-07-24T07:37:28Z",
      "mergedAt": "2021-07-24T07:37:28Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "dc5191883a70ee91ba33856dd2a565bc72fa7815"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjE0MjE3",
          "commit": {
            "abbreviatedOid": "f3d8703"
          },
          "author": "dwaite",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-07-24T07:37:16Z",
          "updatedAt": "2021-07-24T07:37:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOFsQObc4r-MOk",
      "title": "[WIP] Streamlined Scope",
      "url": "https://github.com/json-web-proofs/json-web-proofs/pull/10",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are two significant things to note in this PR:\r\n1. Renaming of the `derive` step and \"derivation\" to the `prove` step and generating proofs, to be more consistent with the usage of \"proofs\" elsewhere in the draft.\r\n2. Removing all language regarding the mapping of what values are in which payload slot, leaving this to the application or a companion spec.\r\n\r\nThe result is a simpler spec that focuses strictly on the cryptographic container with pluggable proof algorithms. ",
      "createdAt": "2021-09-20T16:09:23Z",
      "updatedAt": "2021-10-05T23:37:20Z",
      "baseRepository": "json-web-proofs/json-web-proofs",
      "baseRefName": "main",
      "baseRefOid": "1f8cf966c342cc0f71b484dcce6bc52d5a11cee0",
      "headRepository": "json-web-proofs/json-web-proofs",
      "headRefName": "streamlined_scope",
      "headRefOid": "ec5d1761c451e9407e986470b64104661b495a47",
      "closedAt": "2021-10-05T23:37:16Z",
      "mergedAt": "2021-10-05T23:37:16Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "9e9b7f8681e2257354a93e8b043dc16a37eb607a"
      },
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you @OR13, this is some excellent feedback! \r\n\r\nI've got some work to do incorporating it, which might take me a week or so since I'll be out most of this coming week.",
          "createdAt": "2021-09-25T19:46:18Z",
          "updatedAt": "2021-09-25T19:46:18Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "@OR13 I think I've either made some improvements or filed/linked issues for all the feedback and points you raised, if I missed any I'm happy to keep refining too.",
          "createdAt": "2021-10-05T19:58:42Z",
          "updatedAt": "2021-10-05T19:58:42Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks all for the feedback! ",
          "createdAt": "2021-10-05T23:37:10Z",
          "updatedAt": "2021-10-05T23:37:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4tg--8",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:30:49Z",
          "updatedAt": "2021-09-25T18:30:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I am not sure this change is good. \r\n\r\n`proof-generation` is relevant to JWS/JWT, but `proof-derivation` is a new concept for JOSE  imo.",
              "createdAt": "2021-09-25T18:30:49Z",
              "updatedAt": "2021-09-25T18:30:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg-_4",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:31:46Z",
          "updatedAt": "2021-09-25T18:31:46Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n* [BBS+](https://github.com/mattrglobal/bbs-signatures)\r\n* [MerkleDisclosureProof2021](https://github.com/transmute-industries/merkle-disclosure-proof-2021)\r\n```",
              "createdAt": "2021-09-25T18:31:46Z",
              "updatedAt": "2021-09-25T18:31:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_Du",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:35:17Z",
          "updatedAt": "2021-09-25T18:35:17Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I know what you mean here, but potentially we might use language that overlaps with https://csrc.nist.gov/Projects/pec/zkproof\r\n\r\nSomething to the effect of \"...only a subset of the original claims\" or  \"Proofs of knowledge\"  for the original claims.",
              "createdAt": "2021-09-25T18:35:17Z",
              "updatedAt": "2021-09-25T18:35:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_LZ",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:43:14Z",
          "updatedAt": "2021-09-25T18:43:14Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "\r\nI would prefer to see JWP support interfaces like:\r\n\r\n`create/generate` - construct and secure document and proof.\r\n`derive/prove` - transform a document and proof in such a way that they remain verifiable while's enhancing privacy.\r\n`verify` - verify a document and proof.\r\n\r\nI'm not sure its wise to limit `sign/create` to happening only once.... consider multi-signature scenarios where material is collected from parties over time.\r\n\r\nWe could potential address those scenarios by thinking of `sign` as `contribute to proof` where it might happen once, or a few times.",
              "createdAt": "2021-09-25T18:43:14Z",
              "updatedAt": "2021-09-25T18:43:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_M5",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:44:44Z",
          "updatedAt": "2021-09-25T18:44:44Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "<3 this feels like an excellent way of protecting JWP from over coupling to a particular approach, but we will need to remain vigilant.",
              "createdAt": "2021-09-25T18:44:44Z",
              "updatedAt": "2021-09-25T18:44:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_SL",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:50:41Z",
          "updatedAt": "2021-09-25T18:50:41Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "This feels like too many legal values for a payload....\r\n\r\nIn typescript this type would look like this:\r\n\r\n```\r\ntype Payload: string | number | Buffer | any; // yikes any? really?\r\n```\r\n\r\nThis will cause security issues later.\r\n\r\nIMO, payload should be JSON... if you can't serialize or deserialize JSON (IoT / CBOR/ pure binary use cases)....you probably won't like base64url encoding either... \r\n\r\nAlternatively, we might consider CBOR instead of JSON, but I really don't like the payload not having a single know type.",
              "createdAt": "2021-09-25T18:50:41Z",
              "updatedAt": "2021-09-25T18:50:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_W5",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:55:19Z",
          "updatedAt": "2021-09-25T18:55:19Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "I agree with this, but we should beware of scenarios where time information MUST be disclosed...\r\n\r\nproving I have a DL, without proving it's not expired could be a problem... pushing that information to the payload could cause interop issues, similar to `nbf`, `iat`....",
              "createdAt": "2021-09-25T18:55:19Z",
              "updatedAt": "2021-09-25T18:55:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_ZU",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:57:48Z",
          "updatedAt": "2021-09-25T18:57:48Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "This sounds to me like https://datatracker.ietf.org/doc/html/rfc7638 but applying to JWP protected headers.\r\n\r\nWe should beware of serialization ordering issues with objects.... \r\n\r\nThis digest would function as a correlation identifier for any derived proof.",
              "createdAt": "2021-09-25T18:57:48Z",
              "updatedAt": "2021-09-25T18:57:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_f2",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T19:04:01Z",
          "updatedAt": "2021-09-25T19:04:01Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "We don't have a definition of `value` nor a single type of payload, which makes this sentence very hard to understand....\r\n\r\nIn my preferred world where the payloads are JSON, this might read as:\r\n\r\nThe order and construction of specific payload objects prior to JSON serialization is out of scope for this specification.\r\n\r\nMechanisms for ordering serialized payloads are out of scope for this specification.\r\n\r\nwe need to address both:\r\n\r\n```\r\ntype Payload: JSON | ANY\r\n\r\ntype Payloads: OrderedArray<Payload>\r\n```\r\n\r\nboth are out of scope.\r\n\r\n",
              "createdAt": "2021-09-25T19:04:01Z",
              "updatedAt": "2021-09-25T19:05:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_lp",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T19:09:14Z",
          "updatedAt": "2021-09-25T19:09:15Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "I am not sure I agree with this... how you internally represent EC points is not relevant to a JSON Data Format spec... \r\n\r\nMight be better to say: encoding requirements for libraries that produce JWPs are out of scope, as are defining JSON serializations for ZKP parameters or options.... however I suspect that will have to happen somewhere...\r\n\r\n",
              "createdAt": "2021-09-25T19:09:15Z",
              "updatedAt": "2021-09-25T19:09:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_nH",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T19:11:21Z",
          "updatedAt": "2021-09-25T19:11:21Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "This sentence does not make sense to me... are you meaning to say that the length of `payload: Array<ANY>` is constant / final and hidding values is like doing this:\r\n\r\nitems[disclosureIndex'] = 'hidden' ?\r\n",
              "createdAt": "2021-09-25T19:11:21Z",
              "updatedAt": "2021-09-25T19:11:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_ob",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T19:12:48Z",
          "updatedAt": "2021-09-25T19:12:48Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "this is not possible if disclosure of the original header digest is required.",
              "createdAt": "2021-09-25T19:12:48Z",
              "updatedAt": "2021-09-25T19:12:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_rC",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T19:15:50Z",
          "updatedAt": "2021-09-25T19:15:50Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "As much as I love base64url... it kinda sucks that `-` breaks highlighting... I take it this is one of those cases where the old way of doing things is probably worth preserving more than the improvement, buts its worth noting that base64url inflates data, has no built in error correction, is not \"double clickable\" and allows multiple serializations to deserialize to the same buffer.\r\n\r\nThese issues might not be worth deviating from the convention of just using bas64url, but they are worth noting.",
              "createdAt": "2021-09-25T19:15:50Z",
              "updatedAt": "2021-09-25T19:15:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_t9",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This PR is awesome, I left some comments, none of my comments are blocking as this is DIF not W3C or IETF.\r\n\r\n",
          "createdAt": "2021-09-25T19:18:49Z",
          "updatedAt": "2021-09-25T19:18:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc4t25Wz",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:48:20Z",
          "updatedAt": "2021-10-01T20:48:21Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "JWS supports an unlimited amount of legal values for a payload - in that it's simply signing an array of bytes.  Similarly, the JWP layer should know nothing about the content of ifs payloads, other than their representations as arrays of bytes.",
              "createdAt": "2021-10-01T20:48:21Z",
              "updatedAt": "2021-10-01T20:48:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t25oA",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:50:07Z",
          "updatedAt": "2021-10-01T20:50:08Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "We should talk about \"MUST be disclosed\" payloads on the next DIF Crypto JWP call.  It's a great topic.  That said, I don't think this PR should block on solving that.",
              "createdAt": "2021-10-01T20:50:08Z",
              "updatedAt": "2021-10-01T20:50:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t26Jd",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:53:29Z",
          "updatedAt": "2021-10-01T20:53:29Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "A spec layered about JWP where payloads are JSON should absolutely define this.  We'd tentatively started calling this JSON Selective Disclosure Token (JSDT), I believe.  The beauty of this PR is that it separates concerns, in the same way that concerns are separated between JWS and JWT.",
              "createdAt": "2021-10-01T20:53:29Z",
              "updatedAt": "2021-10-01T20:53:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t26XR",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:54:54Z",
          "updatedAt": "2021-10-01T20:54:54Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "\"that\" is grammatically correct here.  Please revert the change to \"which\".",
              "createdAt": "2021-10-01T20:54:54Z",
              "updatedAt": "2021-10-01T20:54:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t26iJ",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:55:59Z",
          "updatedAt": "2021-10-01T20:55:59Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Another great topic for the next call...",
              "createdAt": "2021-10-01T20:55:59Z",
              "updatedAt": "2021-10-01T20:55:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t29im",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T21:17:43Z",
          "updatedAt": "2021-10-01T21:17:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It seems to me that there's both proof generation and proof derivation steps, as well as a proof verification step.  Which were you intending to talk about here (or maybe both of the first two)?",
              "createdAt": "2021-10-01T21:17:43Z",
              "updatedAt": "2021-10-01T21:17:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t2-LK",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T21:22:40Z",
          "updatedAt": "2021-10-01T21:22:41Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "This has to be in scope somewhere.  It may be the algorithms spec.  It may also make its way into the JSDT spec.  Clean engineering of the layers will be key.",
              "createdAt": "2021-10-01T21:22:40Z",
              "updatedAt": "2021-10-01T21:22:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t2-kS",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T21:25:46Z",
          "updatedAt": "2021-10-01T21:25:46Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Does Derivation move to the JSDT spec?  We may still want to at least informatively say that applications of JWP will do derivation.",
              "createdAt": "2021-10-01T21:25:46Z",
              "updatedAt": "2021-10-01T21:25:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t2-0A",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T21:27:47Z",
          "updatedAt": "2021-10-01T21:27:47Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "I disagree with the \"multiple serializations to deserialize to the same buffer\" comment.  There is a single base64url encoding of any string of bytes.  Given there's a 1:1 correspondence, I don't understand this comment, @OR13 .",
              "createdAt": "2021-10-01T21:27:47Z",
              "updatedAt": "2021-10-01T21:27:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t2-9W",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I believe that this PR moves us forward, and so should be merged.  That said, I'm fine with another commit being added to address some of the comments made in the PR beforehand.",
          "createdAt": "2021-10-01T21:28:57Z",
          "updatedAt": "2021-10-01T21:28:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc4t6-sn",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T15:16:03Z",
          "updatedAt": "2021-10-04T15:16:04Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "https://github.com/decentralized-identity/sidetree/blob/3184bfabd4b01e22c9d56fb16feadb5b303da9c4/lib/core/versions/1.0/Multihash.ts#L208\r\n\r\n```\r\n// Compare the strings instead of buffers, \r\n// because encoding schemes such as base64URL \r\n// can allow two distinct strings to decode into the same buffer.\r\n// e.g. 'EiAJID5-y7rbEs7I3PPiMtwVf28LTkPFD4BWIZPCtb6AMg' and\r\n//      'EiAJID5-y7rbEs7I3PPiMtwVf28LTkPFD4BWIZPCtb6AMv' would decode into the same buffer.\r\n```",
              "createdAt": "2021-10-04T15:16:03Z",
              "updatedAt": "2021-10-04T15:16:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t6_Wm",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T15:18:08Z",
          "updatedAt": "2021-10-04T15:18:09Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "is there a link to JSDT?",
              "createdAt": "2021-10-04T15:18:09Z",
              "updatedAt": "2021-10-04T15:18:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t7BBW",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T15:23:35Z",
          "updatedAt": "2021-10-04T15:23:35Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I am in favor of:\r\n\r\n```\r\ntype PayloadOptions = Buffer;\r\ntype Payload = base64url (Buffer). base64url (PayloadOptions).\r\ntype Payloads = Array<Payload>;\r\n```\r\n\r\nimplementers shouldn't have to care about the payload content, the alg registry should tell you how to care about options or payloads.",
              "createdAt": "2021-10-04T15:23:35Z",
              "updatedAt": "2021-10-04T15:23:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t8svH",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T00:52:09Z",
          "updatedAt": "2021-10-05T00:52:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Regardless of the cryptographic primitive used by the _issuer_, they are still performing the act of signing, the issuer is adding authentication (that they signed it) and integrity.  The holder upon receiving a _signed_ JWP then validates the signature to make sure it is authentic and has integrity.\r\n\r\nWhen interacting with a verifier, the holder derives a proof of authenticity and integrity of the header and disclosed payloads.  The cryptographic primitive is predominately ZKPs, but the act is still proving since the holder isn't the original signer.\r\n\r\nThat's the way I've grown to think about it across all of the papers and code I've read in this space.  I think \"proof generation\" is more appropriate, as it is always an act of creation of a new output that is used to prove. Derivation could have other interpretations/meanings or create the wrong expectations.\r\n",
              "createdAt": "2021-10-05T00:52:09Z",
              "updatedAt": "2021-10-05T00:52:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t8ux_",
          "commit": {
            "abbreviatedOid": "5bb8ad6"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T01:10:30Z",
          "updatedAt": "2021-10-05T01:10:30Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I mentioned in another comment my thought process behind sign/sign_verify and proove/proof_verify language, happy to pick that up in that thread or we can create an issue to continue also.\r\n\r\nGood point about the \"only once\" language, fixing that now :+1: ",
              "createdAt": "2021-10-05T01:10:30Z",
              "updatedAt": "2021-10-05T01:16:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t8wve",
          "commit": {
            "abbreviatedOid": "5d1a886"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T01:32:03Z",
          "updatedAt": "2021-10-05T01:32:04Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "This is an unfortunate complexity I think we'll have to work through and deal with in some form.\r\n\r\nThe JWP _algorithm interface_ simply *must* support rich types.  JWP itself as a container format absolutely treats each payload as an array of bytes, but during the act of signing, proof generation, and proof validation the algorithm has to have the ability to accept rich types.\r\n\r\nThese rich interfaces are language/library level and not part of the protocol, but they are important to support required capabilities such as blinded values (algo has to be given an elliptic curve point), predicate proofs (algo requires a number, set member value, etc).\r\n\r\nThere's no reason to make these encodings be part of the protocol, they really are an implementation language level detail and algorithm specific.  There's not even an interop issue that I can tell since the algorithms that support these have very specific ways they use them via a hash2curve or other such cryptographic transformation.\r\n\r\nI definitely need help explaining this and adding better text around it, so I welcome the discussions :) ",
              "createdAt": "2021-10-05T01:32:03Z",
              "updatedAt": "2021-10-05T01:32:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t8xBg",
          "commit": {
            "abbreviatedOid": "5d1a886"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T01:35:22Z",
          "updatedAt": "2021-10-05T01:35:23Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "I believe we'll be forming a sibling JWP spec that adds semantics around specific claims like JWT. Presentation exchange is also a good place for these types of rules.\r\n\r\nI don't think these payload-specific requirements need to be handled at the core JWP layer other than integrity protecting and disclosing the fixed header. ",
              "createdAt": "2021-10-05T01:35:23Z",
              "updatedAt": "2021-10-05T01:35:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t8xWI",
          "commit": {
            "abbreviatedOid": "5d1a886"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T01:39:13Z",
          "updatedAt": "2021-10-05T01:39:13Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Excellent point @OR13, this definitely needs some language around that, with probably more detail in a security considerations.\r\n\r\nThe protected header SHOULD be minimal and static across all usages of a given key, and static as in simply re-using the digested version.  It's only real purpose is to contain signals of how to process the JWP, key id, etc.",
              "createdAt": "2021-10-05T01:39:13Z",
              "updatedAt": "2021-10-05T01:39:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t_xPH",
          "commit": {
            "abbreviatedOid": "f18fce7"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T16:39:26Z",
          "updatedAt": "2021-10-05T16:39:26Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Agree that the payload contents should be addressed in a companion spec, and I also agree this wording is definitely incomplete and needs more work.",
              "createdAt": "2021-10-05T16:39:26Z",
              "updatedAt": "2021-10-05T16:39:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAB6y",
          "commit": {
            "abbreviatedOid": "f18fce7"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:48:02Z",
          "updatedAt": "2021-10-05T17:48:03Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "I'm going to close this sub-thread since it's the same discussion on the payload encodings above.",
              "createdAt": "2021-10-05T17:48:02Z",
              "updatedAt": "2021-10-05T17:48:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uACoI",
          "commit": {
            "abbreviatedOid": "f18fce7"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:50:24Z",
          "updatedAt": "2021-10-05T17:50:25Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "It is possible when the header digest is static and applies to all JWPs an issuer generates.",
              "createdAt": "2021-10-05T17:50:24Z",
              "updatedAt": "2021-10-05T17:50:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAFfS",
          "commit": {
            "abbreviatedOid": "f18fce7"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:55:21Z",
          "updatedAt": "2021-10-05T17:55:21Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Given that we plan on defining a COSE Proof analog to JWP, my preference is to keep JWP as close to JOSE conventions as possible for easier adoption in those existing environments.\r\n\r\nCOSE Proofs can serve as the basis for much more efficient representations that can be serialized/encoded independently by a constrained transport as needed.",
              "createdAt": "2021-10-05T17:55:21Z",
              "updatedAt": "2021-10-05T17:55:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAGZk",
          "commit": {
            "abbreviatedOid": "7d98b98"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:56:53Z",
          "updatedAt": "2021-10-05T17:56:53Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Corrected.",
              "createdAt": "2021-10-05T17:56:53Z",
              "updatedAt": "2021-10-05T17:56:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAlO0",
          "commit": {
            "abbreviatedOid": "7d98b98"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T19:33:23Z",
          "updatedAt": "2021-10-05T19:33:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I created issue #13 to continue this thread.",
              "createdAt": "2021-10-05T19:33:23Z",
              "updatedAt": "2021-10-05T19:33:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAl70",
          "commit": {
            "abbreviatedOid": "7d98b98"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T19:36:36Z",
          "updatedAt": "2021-10-05T19:36:36Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "\ud83d\udcaf agreed!",
              "createdAt": "2021-10-05T19:36:36Z",
              "updatedAt": "2021-10-05T19:36:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAmGy",
          "commit": {
            "abbreviatedOid": "7d98b98"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T19:37:21Z",
          "updatedAt": "2021-10-05T19:37:21Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Let's continue this in issue #8 ",
              "createdAt": "2021-10-05T19:37:21Z",
              "updatedAt": "2021-10-05T19:37:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAqVv",
          "commit": {
            "abbreviatedOid": "387de07"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T19:57:08Z",
          "updatedAt": "2021-10-05T19:57:09Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Related to issue #8, I also made some minor improvements to this text to be more clear.",
              "createdAt": "2021-10-05T19:57:09Z",
              "updatedAt": "2021-10-05T19:57:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAuAv",
          "commit": {
            "abbreviatedOid": "ec5d176"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T20:14:35Z",
          "updatedAt": "2021-10-05T20:14:35Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "Pushed some improvements here that hopefully clarify also.",
              "createdAt": "2021-10-05T20:14:35Z",
              "updatedAt": "2021-10-05T20:14:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uA4kR",
          "commit": {
            "abbreviatedOid": "ec5d176"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T21:04:50Z",
          "updatedAt": "2021-10-05T21:04:50Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "like this change.",
              "createdAt": "2021-10-05T21:04:50Z",
              "updatedAt": "2021-10-05T21:04:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uA_w4",
          "commit": {
            "abbreviatedOid": "ec5d176"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T21:43:35Z",
          "updatedAt": "2021-10-05T21:43:35Z",
          "comments": []
        }
      ]
    }
  ]
}